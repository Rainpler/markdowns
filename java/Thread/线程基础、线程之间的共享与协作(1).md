>毫不例外，进程与线程会时常伴随着我们在在我们的日常开发中。为了加深对线程与进程理论知识的学习，本文特做记录。
## 进程与线程
#### 进程

我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。

进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。

进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 并发性：任何进程都可以同其他进行一起并发执行；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序，数据和进程控制块三部分组成
#### 线程
在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成，依赖于进程而存在。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。

#### 进程与线程的区别
1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
4. 调度和切换：线程上下文切换比进程上下文切换要快得多

#### CPU核心数和线程数的关系
我们现在使用的手机、笔记本，基本都是多核心的。那么什么是多核心？

在《编程之美》提到，在早期计算机里，一个芯片上只能放一个物理核心，为了提高计算的速度，半导体制程不断发展，使得芯片体积越来越小，这带来许多好处：除了制造成本更低之外，芯片性能也得到提升。芯片不断缩小，就要受到量子物理的约束，受到量子隧穿的影响，再提高晶体管的密度就不行了。于是大家就想到，把多个物理核心集成到一个芯片上。

那么CPU多核的核心数和线程有是么关系呢？

打开Windows电脑的任务管理器，打开性能界面可以看到笔记本的处理器参数。比如我的电脑，Inter(R) Core(TM) i7-4710H @ 2.50GHz 处理器，有4个内核，但是逻辑处理器有8个。一般情况下，内核数和线程数是一对一。前面我们说过，真正执行任务的是线程，但是英特尔使用了超线程技术，物理核心数和逻辑核心数是1:2的关系，意味着计算机上可以同时跑8个线程。但是，我们平时开发的时候，并没有感觉受到线程数的限制，我们想开线程就开。这是因为计算机为我们提供了一种CPU时间片轮转机制，这是一种最古老，最公平，最广泛的调度方法，也称为RR调度。
#### CPU时间片轮转机制
该机制会对CPU时间进行切片，每个进程被分配一时间段，称作它的时间片，即该进程允许运行的时间。

系统会维护一张就绪进程列表，其实就是一个先进先出的队列，新来的进程就会被加到队列的末尾，然后每次执行进程调度的时候，都会选择队列的队首进程，让它在CPU上运行一个时间片的时间，不过如果分配的时间片已经消耗光了而进程还在运行，调度程序就会停止该进程的运行，同时把它移到队列的末尾，CPU会被剥夺并分配给队首进程，而如果进程在时间片结束前阻塞或者结束了，则CPU就会进行切换。

假如我们在键盘敲下asdf这样一行字母，其实就是一瞬间的事。按照查找到的资料，人的反应速度是0.1秒。但是一个1.6GHz CPU执行一条指令的速度是0.6纳秒。一秒钟包含了10亿纳秒。我们按下a的时候，CPU完全可以将这这段时间划分成很多块，然后用一小段时间去完成这个操作，而其他时间都去做其他事，我们人能反应过来吗。


时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的，包括保存和装入寄存器值及内存映像，更新各种表格和队列等。假如进程切(processwitch)，有时称为上下文切换( context switch)，需要5ms，再假设时间片设为20ms，则在做完20ms 有用的工作之后，CPU 将花费5ms 来进行进程切换。CPU 时间的20%被浪费在了管理开销上了。为了提高CPU 效率，我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中，如果有10 个交互用户几乎同时按下回车键，将发生什么情况?假设所有其他进程都用足它们的时间片的话，最后一个不幸的进程不得不等待5s 才获得运行机会。多数用户无法忍受一条简短命令要5 才能做出响应，同样的问题在一台支持多道程序的个人计算机上也会发结论可以归结如下：时间片设得太短会导致过多的进程切换，降低了CPU 效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。在CPU死机的情况下，其实大家不难发现当运行一个程序的时候把CPU 给弄到了100%再不重启电脑的情况下，其实我们还是有机会把它kill掉的，我想也正是因为这种机制的缘故。

我们观察到，现在笔记本上一共存在了133个进程，2599个线程，也就是说远远超过了逻辑处理器的数量。那么CPU是如何调度的呢？

#### 并行和并发
来看一个咖啡机与队列的例子。假如我们有两个队列，他们都想使用咖啡机。

并行：有两台咖啡机，那么就可以让两个队列同时使用。在同一时间可以同时执行不同的任务。

并发：只有一台咖啡机，两个队列只能交替使用咖啡机。时间片轮转机制就是一种并发的实现。

两者区别:一个是交替执行,一个是同时执行。

那么我们为什么要使用高并发编程呢？首先第一个来讲，我们现在的机器都是多核心，我们使用高并发可以充分利用CPU的资源。假如我们现在有8个核心，我们的代码是单线程的，那么只能使用一个核心，不能充分使用处理器的资源假如原来代码执行速度是5秒，我们通过多线程改造，提高到1秒，且不需要做任何服务器的增加。多线程还可以加速用户响应时间，比如我们使用迅雷的时候，通常都会开启多个下载任务，这样速度才更快。

它还能让我们的代码模块化，异步化，比如我们在开发电商应用的时候，用户进行下单后，会进行减库存->通知用户->通知快递->等等一系列操作，如果我们使用串行开发，那么总时间是不是就是所有时间相加起来。其实通知用户这一步，完全跟用户下单的其他操作，是不相关的，完全可以拿出来用另一个线程去完成，这样就可以实现模块化，异步化。

但是高并发编程也存在安全性问题。在一个进程里面，线程是共享进程的资源的，那么这样一来，就会存在资源竞争的问题。为了解决这个问题，我们就不可避免的引入了锁的机制，但是使用锁必然会带来性能的下降，因此，不正确的使用锁，可能会适得其反，甚至不如单线程执行的速度。在OS中，会对线程数进行限制，在Linux中，1个进程限制了1000个线程，在Windows中，1个进程限制了线程上限为2000。为什么要这样呢？我们知道，新建线程的时候，会给它单独分配栈空间，在Java中缺省是1M的大小，因此打开线程会消耗大量的资源，因此不限制线程的数量，分分钟就会导致崩溃，所以我们通常会使用线程池。

## Java中的多线程
在Java中，天生就是多线程的。我们通过下面代码来观察Java虚拟机中的线程信息。
```java
public class OnlyMain {
    public static void main(String[] args) {
        //Java 虚拟机线程系统的管理接口
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
        // 不需要获取同步的monitor和synchronizer信息，仅仅获取线程和线程堆栈信息
        ThreadInfo[] threadInfos =
                threadMXBean.dumpAllThreads(false, false);
        // 遍历线程信息，仅打印线程ID和线程名称信息
        for (ThreadInfo threadInfo : threadInfos) {
            System.out.println("[" + threadInfo.getThreadId() + "] "
                    + threadInfo.getThreadName());
        }
    }
}
```
短短几行代码，Java虚拟机竟然为我们启动了那么多线程。
```java
[6] Monitor Ctrl-Break
[5] Attach Listener
[4] Signal Dispatcher
[3] Finalizer
[2] Reference Handler
[1] main
```
``main``就是主线程，``Finalizer``是所谓的守护线程，我们知道所有类的父类都是``Object``，在``Object``中有一个``finalize()``方法，而我们在学习Java语言时提到过如果需要对资源进行回收，就可以写在这个方法里面。但是即便是写在``finalize()``里面，代码也有可能是不执行的。因为``finalize()``方法正是在``Finalizer``线程中执行的，随着主线程一结束，``Finalizer``线程也跟着结束了，就有可能导致资源回收代码还没跑完。所以不推荐资源回收代码写在``finalize()``中。

#### Java新启线程的方式
那么在Java中，有几种新启线程的方式呢？一般都会说三种：
- 类Thread
- 接口Runable
- 接口Callable

但是我们看一下Thread源码中的注释，它写到：

```
 /**
 * There are two ways to create a new thread of execution. One is to
 * declare a class to be a subclass of <code>Thread</code>. This
 * subclass should override the <code>run</code> method of class
 * <code>Thread</code>.
 *
 * The other way to create a thread is to declare a class that
 * implements the <code>Runnable</code> interface. That class then
 * implements the <code>run</code> method. An instance of the class can
 * then be allocated, passed as an argument when creating
 * <code>Thread</code>, and started.
 */
```
也就是说，有两种启动新线程的方式。一种就是扩展自``Thread``类，然后重写``run()``方法
```Java
private static class UseThread extends Thread{
		@Override
		public void run() {
			super.run();
			// do my work;
			System.out.println("I am extendec Thread");
		}
	}
```
另一种就是实现``Runnable``接口，实现``run()``方法
```java
private static class UseRunnable implements Runnable{

		@Override
		public void run() {
			// do my work;
			System.out.println("I am implements Runnable");
		}
	}
```
当我们使用的时候，对于前者，我们创建一个该类的实例，然后调用``start()``方法。对于后者，我们将runnable作为构造方法参数，创建一个Thread的实例，然后调用``start()``。
```java
public static void main(String[] args) throws InterruptedException, ExecutionException {
		UseThread useThread = new UseThread();
		useThread.start();

		UseRunnable useRunnable = new UseRunnable();
		new Thread(useRunnable).start();
	}
```
#### Thread和RUnnable的区别
Thread是Java里真正意义上对线程的抽象，而Runnable是对任务的抽象。

比如在餐厅里面，A要做接待、要做送餐、要做饭菜、要做收银，那么对于A来说，他就是一个线程(Thread)，他所要做的事就是任务(Runnable)。当餐厅人一多，A一个人忙不过来了，就必须再请多一个B来做饭菜，C来收银。就相当于多新启了几个线程，将任务分配了出去。

#### Java里线程的生命周期
既然有开始就有结束，那么怎么样才能让Java里的线程安全停止工作呢？我们查找Thread源码，可以找到``stop()``，``destroy()``,``suspend()``等方法，但是在上面都打上了``@Deprecated``注解，JDK并不推荐我们使用。因为这些方法带有很强的强制性。拿``suspend()``挂起方法来说，它会强行让一个线程发生上下文切换，从运行状态变成休眠状态，但是相关线程是不会释放资源的。``stop()``会野蛮的把线程直接杀死，它不管当前线程是否正常释放了资源。比如有那么一个写入文件的线程，一共10K大小，写入到4K的时候，``stop()``方法直接杀死了这个线程。正常来说一个完整的文件会有文件终止符，那么后面再去读取这个文件的时候，就会出现异常。

在Thread中还提供了``interrupt``的方法，用于进程的中断。但是查看代码可以看到，有关``interrupt``的方法有三个：
- public void interrupt()
- public static boolean interrupted()
- public boolean isInterrupted()

虽然``interrupt``的方法是用于进程的中断，但是调用其方法的时候，并不是马上中止线程，而是更改它的中断标志位，通俗地讲，就是跟线程打个招呼，告诉它你要中止了。但是线程完全可以不理会，可以继续进行它的工作，是否停止，完全由线程来做主。因为在JDK中，线程是**协作式**的，而不是抢占式的。

来看以下代码，我们来观察``interrupt``方法调用，对子线程产生的影响：
```java
/**
 *类说明：如何安全中断线程
 */
public class EndThread {

	private static class UseThread extends Thread{

		public UseThread(String name) {
			super(name);
		}

		@Override
		public void run() {
			String threadName = Thread.currentThread().getName();
			System.out.println(threadName+" interrrupt flag ="+isInterrupted());
			// while(!isInterrupted()){
				//while(!Thread.interrupted()){
			while(true){
				System.out.println(threadName+" is running");
				System.out.println(threadName+"inner interrrupt flag ="
						+isInterrupted());
			}
			System.out.println(threadName+" interrrupt flag ="+isInterrupted());
		}
	}

	public static void main(String[] args) throws InterruptedException {
		Thread endThread = new UseThread("endThread");
		endThread.start();
		Thread.sleep(20);
		endThread.interrupt();//中断线程，其实设置线程的标识位true
	}
}
```
当我们循环条件为``while(true)``时，执行``endThread.interrupt();``代码，子线程并没有收到影响，仍旧在继续运行着，但是从log中可以看到``interrrupt flag``已经被更改为``true``了。

我们再把循环条件改为``while(!isInterrupted())``并在此运行代码，调用``endThread.interrupt();``后，子线程会终止，interrrupt flag修改为``true``。我们再看	``while(!Thread.interrupted())``，这是Thread类提供的静态方法，它同样可以判断线程的中断标志位，只不过，它会将interrrupt flag修改为``false``。我们观察源码比较这两个方法的区别。
```java
public static boolean interrupted() { 
    return currentThread().isInterrupted(true);
}

public boolean isInterrupted() {
    return isInterrupted(false);
}
/**
  * Tests if some Thread has been interrupted.  The interrupted state
  * is reset or not based on the value of ClearInterrupted that is
  * passed.
  */
private native boolean isInterrupted(boolean ClearInterrupted);
```
``Thread.interrupted()``和``isInterrupted()``方法最后都是调用了``native``的``isInterrupted``方法，我们可以看到该参数的命名为清除中断标志位，也就是说基于传入的boolean变量，决定是否要重置中断标志位。

在我们的有的同学日常开发中，可能会采用这样的中断方式，自定义一个isCanceled的boolean型变量，再定义一个setCanceled()的方法来使线程中断。但是并不建议这么做，当在线程中调用了sleep()或者wait()方法被挂起后，线程根本不会去判断isCanceled。但是使用Thread的中断标志位，即便线程被挂起了，也是可以检测到的。
