>毫不例外，进程与线程会时常伴随着我们在在我们的日常开发中。为了加深对线程与进程理论知识的学习，本文特做记录。
## 进程与线程
#### 进程

我们都知道计算机的核心是CPU，它承担了所有的计算任务，而操作系统是计算机的管理者，它负责任务的调度，资源的分配和管理，统领整个计算机硬件；应用程序是具有某种功能的程序，程序是运行于操作系统之上的。

进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。

进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序，数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块包含进程的描述信息和控制信息是进程存在的唯一标志

进程具有的特征：

- 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
- 并发性：任何进程都可以同其他进行一起并发执行；
- 独立性：进程是系统进行资源分配和调度的一个独立单位；
- 结构性：进程由程序，数据和进程控制块三部分组成
#### 线程
在早期的操作系统中并没有线程的概念，进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。

后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID，当前指令指针PC，寄存器和堆栈组成，依赖于进程而存在。而进程由内存空间(代码，数据，进程空间，打开的文件)和一个或多个线程组成。

#### 进程与线程的区别
1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线
3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；
4. 调度和切换：线程上下文切换比进程上下文切换要快得多

#### CPU核心数和线程数的关系
我们现在使用的手机、笔记本，基本都是多核心的。那么什么是多核心？

在《编程之美》提到，在早期计算机里，一个芯片上只能放一个物理核心，为了提高计算的速度，半导体制程不断发展，使得芯片体积越来越小，这带来许多好处：除了制造成本更低之外，芯片性能也得到提升。芯片不断缩小，就要受到量子物理的约束，受到量子隧穿的影响，再提高晶体管的密度就不行了。于是大家就想到，把多个物理核心集成到一个芯片上。

那么CPU多核的核心数和线程有是么关系呢？

打开Windows电脑的任务管理器，打开性能界面可以看到笔记本的处理器参数。比如我的电脑，Inter(R) Core(TM) i7-4710H @ 2.50GHz 处理器，有4个内核，但是逻辑处理器有8个。一般情况下，内核数和线程数是一对一。前面我们说过，真正执行任务的是线程，但是英特尔使用了超线程技术，物理核心数和逻辑核心数是1:2的关系，意味着计算机上可以同时跑8个线程。但是，我们平时开发的时候，并没有感觉受到线程数的限制，我们想开线程就开。这是因为计算机为我们提供了一种CPU时间片轮转机制，这是一种最古老，最公平，最广泛的调度方法，也称为RR调度。
#### CPU时间片轮转机制
该机制会对CPU时间进行切片，每个进程被分配一时间段，称作它的时间片，即该进程允许运行的时间。

系统会维护一张就绪进程列表，其实就是一个先进先出的队列，新来的进程就会被加到队列的末尾，然后每次执行进程调度的时候，都会选择队列的队首进程，让它在CPU上运行一个时间片的时间，不过如果分配的时间片已经消耗光了而进程还在运行，调度程序就会停止该进程的运行，同时把它移到队列的末尾，CPU会被剥夺并分配给队首进程，而如果进程在时间片结束前阻塞或者结束了，则CPU就会进行切换。

假如我们在键盘敲下asdf这样一行字母，其实就是一瞬间的事。按照查找到的资料，人的反应速度是0.1秒。但是一个1.6GHz CPU执行一条指令的速度是0.6纳秒。一秒钟包含了10亿纳秒。我们按下a的时候，CPU完全可以将这这段时间划分成很多块，然后用一小段时间去完成这个操作，而其他时间都去做其他事，我们人能反应过来吗。但是，时间片轮转机制也存在一定的问题，由于进程是需要占用资源的，当其分配到的时间片用完了，就要让出CPU的使用和相应的资源，等到下一次时间片的再重新获取。这就是所说的上下文的切换，而这个操作是很耗费时间的，大概会花费20000个CPU周期。

我们观察到，现在笔记本上一共存在了133个进程，2599个线程，也就是说远远超过了逻辑处理器的数量。那么CPU是如何调度的呢？

#### 并行和并发
来看一个咖啡机与队列的例子。假如我们有两个队列，他们都想使用咖啡机。

并行：有两台咖啡机，那么就可以让两个队列同时使用。在同一时间可以同时执行不同的任务。

并发：只有一台咖啡机，两个队列只能交替使用咖啡机。时间片轮转机制就是一种并发的实现。

那么我们为什么要使用高并发编程呢？首先第一个来讲，我们现在的机器都是多核心，我们使用高并发可以充分利用CPU的资源。假如我们现在有8个核心，我们的代码是单线程的，那么只能使用一个核心，不能充分使用处理器的资源假如原来代码执行速度是5秒，我们通过多线程改造，提高到1秒，且不需要做任何服务器的增加。多线程还可以加速用户响应时间，比如我们使用迅雷的时候，通常都会开启多个下载任务，这样速度才更快。

它还能让我们的代码模块化，异步化，比如我们在开发电商应用的时候，用户进行下单后，会进行减库存->通知用户->通知快递->等等一系列操作，如果我们使用串行开发，那么总时间是不是就是所有时间相加起来。其实通知用户这一步，完全跟用户下单的其他操作，是不相关的，完全可以拿出来用另一个线程去完成，这样就可以实现模块化，异步化。

但是高并发编程也存在安全性问题。在一个进程里面，线程是共享进程的资源的，那么这么一来，就会存在资源竞争的问题。为了解决这个问题，我们就不可避免的引入了锁的机制，但是使用锁必然会带来性能的下降，因此，不正确的使用锁，可能会适得其反，甚至不如单线程执行的速度。在OS中，会对线程数进行限制，在Linux中，1个进程限制了1000个线程，在Windows中，1个进程限制了线程上限为2000。为什么要这样呢？我们知道，新建线程的时候，会给它单独分配栈空间，在Java中缺省是1M的大小，因此打开线程会消耗大量的资源，因此不限制线程的数量，分分钟就会导致崩溃，所以我们通常会使用线程池。
