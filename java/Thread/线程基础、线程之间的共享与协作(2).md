## ThreadLocal辨析
#### 与Synchonized的比较
ThreadLocal 和 Synchonized 都用于解决多线程并发访问。可是 ThreadLocal 与 synchronized 有本质的差别。synchronized 是利用锁的机制，使变量或代码块 在某一时该仅仅能被一个线程访问。而 ThreadLocal为每个线程都提供了变量的 副本，使得每个线程在某一时间访问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。

#### ThreadLocal 的使用
ThreadLocal 类接口很简单，只有 4 个方法，我们先来了解一下：
- void set(Object value)
  设置当前线程的线程局部变量的值。
- public Object get()
  该方法返回当前线程所对应的线程局部变量。
- public void remove()
  将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是 JDK 5.0 新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动 被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它 可以加快内存回收的速度。
- protected Object initialValue()
  返回该线程局部变量的初始值，该方法是一个 protected 的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第 1 次调用 get() 或 set(Object)时才执行，并且仅执行 1 次。ThreadLocal 中的缺省实现直接返回一 个 null。
- public final static ThreadLocal<String> RESOURCE = new ThreadLocal<String>();
  RESOURCE代表一个能够存放String类型的ThreadLocal对象。 此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。
#### ThreadLocal的实现

#### Spring中的ThreadLocal
Spring的事务就借助了ThreadLocal 类。Spring 会从数据库连接池中获得一个connection，然会把connection 放进ThreadLocal中，也就和线程绑定了，事务需 要提交或者回滚，只要从ThreadLocal 中拿到 connection进行操作。为何Spring的事务要借助ThreadLocal 类？以 JDBC为例，正常的事务代码可能如下：
- dbc = new DataBaseConnection();
- Connection con = dbc.getConnection();
- con.setAutoCommit(false);
- con.executeUpdate(...);
- con.executeUpdate(...);
- con.executeUpdate(...);
- con.commit();

上述代码，可以分成三个部分: 事务准备阶段：第1～3行业务处理阶段：第 4～6 行事务提交阶段：第7行可以很明显的看到，不管我们开启事务还是执行具体的sql都需要一个具体的数据库连接。

现在我们开发应用一般都采用三层结构，如果我们控制事务的代码都放在 DAO(DataAccessObject)对象中，在 DAO 对象的每个方法当中去打开事务和关闭 事务，当 Service 对象在调用 DAO 时，如果只调用一个 DAO，那我们这样实现则 效果不错，但往往我们的 Service 会调用一系列的 DAO 对数据库进行多次操作， 那么，这个时候我们就无法控制事务的边界了，因为实际应用当中，我们的 Service 调用的 DAO 的个数是不确定的，可根据需求而变化，而且还可能出现 Service调用 Service 的情况。

但是需要注意一个问题，如何让三个DAO使用同一个数据源连接呢？我们 就必须为每个 DAO 传递同一个数据库连接，要么就是在 DAO 实例化的时候作为 构造方法的参数传递，要么在每个DAO的实例方法中作为方法的参数传递。这 两种方式无疑对我们的 Spring 框架或者开发人员来说都不合适。为了让这个数据 库连接可以跨阶段传递，又不显示的进行参数传递，就必须使用别的办法。

Web 容器中，每个完整的请求周期会由一个线程来处理。因此，如果我们能将一些参数绑定到线程的话，就可以实现在软件架构中跨层次的参数共享（是隐式的共享）。而 JAVA 中恰好提供了绑定的方法——使用ThreadLocal。

结合使用 Spring 里的 IOC 和 AOP，就可以很好的解决这一点。只要将一个数据库连接放入 ThreadLocal 中，当前线程执行时只要有使用数 据库连接的地方就从 ThreadLocal 获得就行了。
