## 深入理解对象
我们知道，Java是一门面向对象设计的语言，面向对象的程序设计语言中有类和对象的概念。类就是具备某些共同特征的实体的集合，它是一种抽象的数据类型，它是对所具有相同特征实体的抽象。在面向对象的程序设计语言中，类是对一类“事物”的属性与行为的抽象。

而对象是类的具体的个体。比如，小王是Person类的一个对象。Person可能存在无数个对象（就好像地球上存在数十亿人一样）。而一个对象的创建，包括两个过程：初始化和实例化。
#### 虚拟机中对象的创建过程
下面是对象创建过程的一个图示：

![](https://ftp.bmp.ovh/imgs/2021/03/c54b392e05ec2cc3.jpg)

我们通常使用new关键字去创建一个对象，JVM首先会去检查相关类型是否已经加载并初始化，如果没有，JVM就会调用类加载器完成类的初始化。接下来，就会为对象分配内存空间。

我们知道Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，而这段内存又必须是连续的。分配的方式通常有指针碰撞和空闲列表两种实现。

- 指针碰撞法

假设Java堆中内存时完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。使用的GC收集器：Serial、ParNew，适用堆内存规整（即没有内存碎片）的情况下。这类垃圾收集器带有压缩整理功能。

- 空闲列表法

事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。使用的GC收集器：CMS，适用堆内存不规整的情况下。而这也就是现代Java虚拟机的垃圾回收机制：标机-清除法。

我们都知道JVM是多线程的，假设线程1正在给A对象分配内存，指针还没有来的及修改，同时线程2在为B对象分配内存，仍引用这之前的指针指向等，这时候就会带来并发安全问题。为了解决并发安全问题，JVM采用了CAS加失败重试的机制以及本地线程分配缓冲的机制。前者属于乐观锁的一种，而CAS操作是一个原子操作，线程会先尝试去分配内存，更新的时候进行比较，如果内存块与期待值相同，则提交修改，如果不同，则自旋，重新移动指针。

而本地线程分配缓冲的机制的话，则是预先给线程分配一块空间TLAB(Thread Local Allocation Buffer)，后面分配空间先在TLAB上分配，TLAB不够了再从堆上分配。

其实TLAB只是让每个线程在堆上有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已，。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管。

当我们为一个对象分配好内存空间之后，还需要进行内存空间的初始化为零值，这一操作保证了对象的实例字段在java代码中，不赋初始值就可以直接使用。例如一个Integer对象，就初始化为0，一个Boolean对象初始化为false。

接下来，就会对内存空间进行设置，将其与对象的实例关联起来，就是在对象头中记录相关的信息。到这里对象的初始化，就完成了。

#### 对象的内存布局
在一个对象里面，包括对象头、实例数据和对齐填充三个部分。在Hotspot里面，对象必须是8字节的整数倍大小，假如对象头加实例数据加起来为30字节的话，则会填充2字节的填充数据，以达到规整的目的。

在对象头里面，包含了多个数据，一是存储自身对象的运行时数据，包括哈希码、GC分代年龄、锁状态表示、线程持有的帧、偏向线程ID，偏向时间戳等。二是类型指针，确定对象是来自哪个实例。三是假如对象是数组对象，还有会一部分数据用来记录数组长度的数据。
#### 对象的访问定位
我们在new出一个对象的时候，其实是使用一个引用去指向一个对象的实例。那么引用是怎么访问定位到对象上呢。
##### 使用句柄
在这里，句柄被定义为了存放到对象实例数据的指针和到对象类型数据的指针的个体，而Java堆又划分了一块句柄池用于存放句柄。而Java栈帧中的局部变量表中存放了对象的reference（引用），而这个引用则指向了句柄池中的句柄，并进而通过指针去定位到对象的实例数据。

##### 直接指针
而使用直接指针的话，引用直接指向了Java堆中的对象实例数据，相比句柄的使用无需二次映射，更加高效了。

#### 对象的存活以及各种引用
我们知道，Java堆是用于分配对象实例的，当堆空间已经满的情况下，JVM就会进行垃圾回收。那么我们就必须区分，哪些对象需要回收，也就是哪些对象是死的，哪些对象是活的。在虚拟机规范里面，有那么几种方法：
##### 引用计数算法（Reference Counting）：
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象，就会被认为是垃圾。使用引用计数器，具有较高的效率，但是它有一个缺陷，那就是很难解决对象之间的循环引用问题，例如objA.instance = objB及objB.instance = objA，如果除此之外这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知GC收集器回收它们。
```java
public class IsAlive {
    public Object instance =null;
    //占据内存，便于判断分析GC
    private byte[] bigSize = new byte[10*1024*1024];

    public static void main(String[] args) {
        IsAlive objectA = new IsAlive();
        IsAlive objectB = new IsAlive();
        //相互引用
        objectA.instance = objectB;
        objectB.instance = objectA;
        //切断可达
        objectA =null;
        objectB =null;
        //强制垃圾回收
        System.gc();
    }
}
```
##### 可达性分析算法（Reachability Analysis）：
通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（即从GC Roots到这个对象不可达）时，则证明此对象是不可用的。
在Java语言中，可作为GC Roots的对象包括以下几种：
(1) 虚拟机栈中引用的对象；
(2) 方法区中类静态属性引用的对象；
(3) 方法区中常量引用的对象；
(4) 本地方法栈中JNI（即一般说的Native方法）引用的对象；

但是如果有引用链，就一定不会被回收吗？还要看对象之间的引用关系。JVM里面有四种引用关系。
- 强引用
- 软引用 SoftReference
- 弱引用 WeakReference
- 虚引用 PhantomReference

强引用通常就是用等号来引用，GC不会回收被强引用的对象。而软引用的话，当快要发生内存溢出的话，就会被GC回收。如果是弱引用的话，当发生GC的时候，就会被回收掉。虚引用被定义出来之后则随时都可能会被GC回收。

**测试软引用**
```java
public static void main(String[] args) {

		User u = new User(1,"King"); //new是强引用
		SoftReference<User> userSoft = new SoftReference<User>(u);//软引用
		u = null;//干掉强引用，确保这个实例只有userSoft的软引用
		System.out.println(userSoft.get()); //看一下这个对象是否还在
		System.gc();//进行一次GC垃圾回收  千万不要写在业务代码中。
		System.out.println("After gc");
		System.out.println(userSoft.get());
		//往堆中填充数据，导致OOM
		List<byte[]> list = new LinkedList<>();
		try {
			for(int i=0;i<100;i++) {
				//System.out.println("*************"+userSoft.get());
				list.add(new byte[1024*1024*1]); //1M的对象
			}
		} catch (Throwable e) {
			//抛出了OOM异常时打印软引用对象
			System.out.println("Exception*************"+userSoft.get());
		}

	}
```
**测试弱引用**
```java
public static void main(String[] args) {
		User u = new User(1,"King");
		WeakReference<User> userWeak = new WeakReference<User>(u);
		u = null;//干掉强引用，确保这个实例只有userWeak的弱引用
		System.out.println(userWeak.get());
		System.gc();//进行一次GC垃圾回收,千万不要写在业务代码中。
		System.out.println("After gc");
		System.out.println(userWeak.get());
	}
```
#### 对象的分配策略
**对象的分配原则**
JVM在创建对象的过程中，分配存储空间的时候通常需要遵循以下原则：
- 对象优先在Eden中分配
- 空间分配担保
- 大对象直接进入老年代
- 长期存活的对象进入老年代
- 动态对象年龄判断

**分配策略优化**
同时，分配的时候也有如下的优化技术：
- 栈中优化对象：逃逸分析
- 堆中的优化技术：本地线程分配缓冲（TLAB）

当JVM遇到一条new指令的时候，首先判断是否在栈上分配，这时候就会使用到逃逸分析技术。在JIT的过程中，如果发现一个对象在方法中被定义后，作用域仅仅限于方法内，那么就称为没有发生方法逃逸，这时候，对象的分配就可以在栈上分配，当方法体执行结束了，栈上的空间也就跟着释放了，这样就可以提高JVM的效率，减少了GC的次数。

通过``-XX:±DoEscapeAnalysis`` ： 表示开启或关闭逃逸分析

接下来，如果不满足逃逸分析，就判断是否在TLAB上分配，如果不满足，再进一步判断是否是大对象，如果不是的话，就会在Eden中分配。所以说，无论是TLAB，还是小对象，都满足对象优先在Eden上分配的原则。如果是大对象的话，则会在Tenured中分配。


## 垃圾回收机制
#### 分代回收理论

Oracle公司曾经进行过概率统计，在新生代中约98%的对象会在创建出来之后的第一次GC就会被回收掉（朝生夕死），所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。

我们知道Eden上只存放新生对象，而堆上又频繁着在发生GC回收，如果某个对象在GC中没有被回收掉，那个在对象的对象头的年龄上就会+1，然后从Eden移动到Survivor中。当再次发生回收时，将Survivor中还存活着的对象一次性的复制到另外一块Survivor，最后清理刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。这种发生在新生代上的GC回收算法被称为复制回收算法。

| Eden | From | To  | Tenured |
| ---- | ---- | --- | ------- |
| 8  | 1  | 1  | 20     |

而在对象头上，64位的JVM中age的比特位是只有4位的，因此能记录的最大年龄也就是1111（15次）。达到这个次数之后，对象就会进入老年代。

当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

空间分配担保，这是在老年代中的垃圾回收算法。正常的流程来讲，对象的跨代移动都是从Eden到From到To，直到GC年龄达到阈值后才会进入Tenured。

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，

- 如果大于，则此次Minor GC是安全的
- 如果小于，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。
如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。

上面提到了Minor GC依然会有风险，是因为新生代采用复制收集算法，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。

老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象，但一共有多少对象在内存回收后存活下来是不可预知的，因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。

取平均值仍然是一种概率性的事件，如果某次Minor GC后存活对象陡增，远高于平均值的话，必然导致担保失败，如果出现了分配担保失败，就只能在失败后重新发起一次Full GC。虽然存在发生这种情况的概率，但大部分时候都是能够成功分配担保的，这样就避免了过于频繁执行Full GC。


#### 垃圾收集算法
##### 标记-清除算法
在标记-清除算法的时候，内存区域的状态可分为可回收、不可回收、未分配三种状态。算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。但是这种算法存在两个缺点：
1. 标记和清除的效率较低
2. 算法执行完后会产生大量的不连续的内存碎片，内存碎片较大会导致大对象无法得到足够空间分配而提早发生GC，甚至std。

##### 复制回收算法
为了解决标记-清除算法效率低的问题，复制回收算法就出现了。我们前面已经讲了，在新生代中采取的垃圾回收算法就是复制回收算法。内存中会分出了两个较小的Survivor区，当发生垃圾回收的时候，会将一块Survivor中存活的对象一次性复制到另一块Survivor，然后清理掉其他空间。再次发生垃圾回收的时候，重复这个过程。这种实现简单，运行高效，因为采取的是内存复制，所以没有内存碎片，但是利用率只有一半。

##### 标记-整理算法
复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。但是这种算法也会存在一些问题，首先就是老年代中的对象大部分都是存活的，因此对象移动会带来效率的下降。其次在大部分的虚拟机中，对象都是直接引用，所以对象的移动也会造成引用的更新，所以这时候用户线程需要暂停。

#### JVM中常见的垃圾收集器
在JVM中，负责GC回收的是不同的垃圾收集器，而垃圾收集器基本又可分为以下三种：
- 单线程垃圾收集器
- 多线程并行垃圾收集器
- 多线程并发垃圾收集器

而在新生代跟老年代中，又分别运行着不同的垃圾收集器。

**新生代**
| 收集器            | 收集对象和算法       | 收集器类型         |
| ----------------- | -------------------- | ------------------ |
| Serial            | 复制算法             | 单线程             |
| ParNew            | 复制算法             | 并行的多线程收集器 |
| Parallel Scavenge | 复制算法             | 并行的多线程收集器 |

**老年代**
| 收集器       | 收集对象和算法                      | 收集器类型         |
| ------------ | ----------------------------------- | ------------------ |
| Serial Old   | 标记整理算法                        | 单线程             |
| Parallel Old | 标记整理算法                        | 并行的多线程收集器 |
| CMS          | 标记清除算法                        | 并行与并发收集器   |
| G1           | 跨新生代和老年代；标记整理+化整为零 | 并行与并发收集器   |

在JVM刚诞生的时候，新生代跟老年代运行的垃圾收集器都是单线程的Serial，相对比较简单。后来随着JVM的发展，内存越来越多，GC回收的效率也需要随之提高。这时候又出现了ParNew和Parallel Old收集器。它们运行的算法跟单线程的时候一样，只不过由单线程变成了并行的多线程。

但是无论是单线程还是并行多线程，都不可避免的在进行垃圾回收的时候，需要暂停所有的用户线程。就比如我们在客厅吃瓜子的时候，老妈进来清理打扫房间，她就会叫你让开，这时候你就只能暂停一会儿让老妈清扫完再继续。但是每次GC，都让所有的用户线程停下，就会很影响效率，因此又发展出了多线程并发垃圾收集器。

**CMS垃圾收集器**
出现的第一个并发垃圾收集器是老年代中运行的CMS（Concurrent Mark-Sweep）。在并发的情况下，用户线程和垃圾回收线程同时执行，但是这样子一来，一边嗑瓜子一边打扫的话，怎么也清理不完吧。所以CMS对GC的过程进行了一个划分。在初始标记阶段，仅仅只是标记一下GC Roots能直接关联到的对象，暂停所有用户线程，但是时间很短。在并发标记阶段，进行GC Roots Tracing的过程，用户线程和垃圾回收线程同时执行，时间较长。在重新标记阶段，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，会暂停所有用户线程，但是时间很短。最后并发清除的阶段，用户线程和垃圾回收线程是的同时执行。

但是CMS的在垃圾清除是使用并发清除的，如果处理器核数不高的情况下，垃圾回收会造成很高的负载。而且在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，而这部分的垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留在下次垃圾收集时再清理掉。这样的垃圾就叫做浮动垃圾。因为CMS收集器不能像其他收集器那样几乎填满了再进行收集，需要预留一些空间用来保存用户新创建的对象。而由于CMS老年代使用标记-清除回收策略，因此也会有内存碎片问题。

如果空间不够，而CMS垃圾收集器又不能处理的时候，就会从CMS切换为单线程的Serial Old，使用标记整理算法去重新进行垃圾的回收，以便为内存分配提供更多的空间。

**G1垃圾收集器**

G1（Garbage First）重新定义了堆空间，打破了原有的分代模型，将堆划分为一个个区域。这么做的目的是在进行收集时不必在全堆范围内进行，这是它最显著的特点。区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。

在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。在堆的结构设计时，G1打破了以往将收集范围固定在新生代或老年代的模式，G1将堆分成许多相同大小的区域单元，每个单元称为Region。Region是一块地址连续的内存空间。

G1收集的运作过程大致如下：

- 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。
- 并发标记（Concurrent Marking）：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。
- 最终标记（Final Marking）：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。
- 筛选回收（Live Data Counting and Evacuation）：首先对各个R egion的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Regions作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。
#### StopTheWorld详解
无论我们使用哪种垃圾收集器，都不可避免的要暂停用户线程，我们称之为Stop the world（stw）。如果不进行std操作的话，垃圾回收线程就永远不可能收集完垃。但是stw相应会带来响应时间的下降，带来用户使用上的卡顿。

#### 常量池
在JVM中，常量池实际上分为两种形态，一种是静态常量池，一种是运行时常量池。常量池的存在是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
##### 静态常量池
静态常量池是Class文件常量池（编译后的class文件的常量池），主要用于存放两大类常量：
- 字面量(Literal)
- 符号引用量(Symbolic References)。

##### 运行时常量池
jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存的方法区中，符号引用就会变为直接引用，对象头的hashcode就是对应一个实体。我们常说的常量池，就是指方法区中的运行时常量池。

##### String的创建分配内存地址
我们观察String的源码，其中用来存在character字符的数组，是被final修饰的，说明String对象一旦被创建出来，值便不可以改变。
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];

    /** Cache the hash code for the string */
    private int hash; // Default to 0
    ...
}
```
以代码为例：
```java
String str="abc"
```
代码编译时，会在常量池中创建常量“abc”,运行时，返回常量池中的字符串引用。
```java
String str=new String("abc")
```
1. 代码编译时，会在常量池中创建常量“abc”
2. 在调用new时，会在堆中创建String对象，并引用常量池中的字符串对象char[]数组，返回String对象引用。

``String.intern()``可以检查字符串常量池中是否存在String并返回池里的字符串引用。若池中不存在，则将其加入池中，并返回其引用，这样做主要是为了避免在堆中不断地创建新的字符串对象。

因此，关于字符串的地址比较可以得出下面的结论：
```java
String s1 = "Hello";
String s2 = "Hello";
String s3 = "Hel" + "lo";
String s4 = "Hel" + new String("lo");
String s5 = new String("Hello");
String s6 = s5.intern();
String s7 = "H";
String s8 = "ello";
String s9 = s7 + s8;


System.out.println(s1 == s2);  // true

//所有参与拼接的部分都是已知的字面量，在编译期间，这种拼接会被优化，编译器直接帮你拼好
System.out.println(s1 == s3);  // true

//对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中
System.out.println(s1 == s4);  // false

//s7、s8作为两个变量，都是不可预料的，编译器毕竟是编译器，不可能当解释器用，不能在编译期被确定
//所以不做优化，只能等到运行时，在堆中创建s7、s8拼接成的新字符串，在堆中地址不确定，不可能与方法区常量池中的s1地址相同
System.out.println(s1 == s9);  // false

//二者都在堆中，但地址不同
System.out.println(s4 == s5);  // false

//s5在堆中，内容为Hello ，intern方法会尝试将Hello字符串添加到常量池中，并返回其在常量池中的地址
//因为常量池中已经有了Hello字符串，所以intern方法直接返回地址
System.out.println(s1 == s6);  // true
```
#### 面试常见问题分析
