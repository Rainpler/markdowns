为什么会发生事件冲突呢，因为我们的xml布局中，是viewgroup包裹view的形式，因此view与view之间必定存在一个叠加的情况。当点击事件产生在view与view的重叠区，该由谁来处理这个事件，这就会导致事件冲突的发生。

首先，我们先来看两个事件冲突的例子。
## 同一个控件的事件冲突
### onTouchListener与onClickListener
在这个例子中，对同一个按钮设置了onTouchListener和onClickListener，且在onTouch中返回了true，那么这会导致什么情况发生呢。Log中只有onTouch会被打印出来。明明都设置了事件为什么不能同时并存呢，这时候我们就要查看事件分发的代码了。
```java
public class MainActivity extends AppCompatActivity {

    private Button btn_click;
    private static final String TAG = "MainActivity";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        btn_click = findViewById(R.id.btn_click);
        btn_click.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.e(TAG, "onClick");
            }
        });
        btn_click.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                Log.e(TAG, "onTouch: " + event.getAction());

                return true;
            }
        });
    }
}
```


在View的dispatchTouchEvent中可以看到，首先会检查mOnTouchListener!=null和view的状态是否为ENABLED两个条件是否成立，如果成立的话，则会调用listener的onTouch()方法，且onTouch()返回了 true ，这个事件就会被消费。

否则，则调用自身的onTouchEvent()来处理。

```java
public boolean dispatchTouchEvent(MotionEvent event) {
      ...
      //noinspection SimplifiableIfStatement
      ListenerInfo li = mListenerInfo;
      if (li != null && li.mOnTouchListener != null
              && (mViewFlags & ENABLED_MASK) == ENABLED
              && li.mOnTouchListener.onTouch(this, event)) {
          result = true;
      }

      if (!result && onTouchEvent(event)) {
          result = true;
      }
      ...
      return result;
```
在View的onTouchEvent()方法中，会判断其是否可以点击，clickable或者longClickable，contextClickable，如果可以点击，则调用PerformClick()方法，并返回true表示消费事件，否则返回false。
```java
public boolean onTouchEvent(MotionEvent event) {
        ...

        final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
                || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

        if ((viewFlags & ENABLED_MASK) == DISABLED) {
            return clickable;
        }


        if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
            switch (action) {
                case MotionEvent.ACTION_UP:
                    if (mPerformClick == null) {
                          mPerformClick = new PerformClick();
                    }
                    if (!post(mPerformClick)) {
                        performClickInternal();
                    }
                    ...
                    break;

                case MotionEvent.ACTION_DOWN:
                    ...
                    break;

                case MotionEvent.ACTION_CANCEL:
                    ...
                    break;

                case MotionEvent.ACTION_MOVE:
                    ...

                    break;
            }

            return true;
        }

        return false;
    }
```

## 不同控件的事件冲突
### ViewPager与ListView的滑动冲突
我们再来看另一个例子，在布局中，我们放一个自定义的viewpager，viewpager中放一个竖向的ListView列表。在自定义的viewpager中，我们重写onInterceptTouchEvent。
```java
public class BadViewPager extends ViewPager {

      @Override
      public boolean onInterceptTouchEvent(MotionEvent event) {

       return true;
       // return false;
     }
```
当onInterceptTouchEvent方法返回为true的时候，表示拦截子view的touch事件，这样会导致viewpager可以作为滑动，但是listview无法滑动。如果返回为false的话，表示不拦截子view，这时候会导致listview可以滑动，但viewpager无法滑动，因此此时该事件。如果我们直接将该方法注释掉，这时viewpager和listview都可以滑动了。这就是一个事件冲突的例子，在这里，只是Google为事件冲突进行了处理。

如果我们想要自己来解决这个事件冲突的话要怎么做呢？我们再来回顾事件分发的流程。首先当ACTION_DOWN事件到来的时候，由于事件分发是自上而下的，这时候会进入先viewpager的dispathTouchEvent方法。

基于此，我们可以有从listview角度的内部处理与从viewpager角度的外部处理。

#### 内部处理

内部处理就是从listview的dispathTouchEvent方法去解决事件的冲突，由于我们期望的实现是左右滑动的时候，viewpager可以正常切换，上下滑动的时候，listview可以正常滚动。所以就是在左右滑动的时候，让listview不要去消费事件。在上下活动的时候，不允许viewpager拦截事件。
```java
class MyListView extends ListView{
    private int mLastX;
    private int mLastY;

    @Override
    public boolean dispathTouchEvent(MotionEvent event) {
        int x = (int)event.getX();
        int y = (int)event.getY();

        switch(event.getAction()){
          case ACTION_DOWN:
              getParent().requestDisallowInterceptTouchEvent(true);
              break;
          case ACTION_MOVE:
              int delX = x - mLastX;
              int delY = y - mLastY;
              if(Math.abs(delX) > Math.abs(delY)){
                  //左右滑动
                  getParent().requestDisallowInterceptTouchEvent(false);
              }
              break;
          case ACTION_UP:
              break;

          default:
              break;

        }
        mLastX = x;
        mLastY = y;
        return super.dispathTouchEvent(event);
    }
}

```

#### 外部处理
当从viewpager的角度去处理的时候，由于事件是从它分发到了listview，所以这时候就要自己决定该事件是否要分发。
```java
class MyViewPager extends ViewPager{
    private int mLastX;
    private int mLastY;

    @Override
    public boolean onInterceptTouchEvent(MotionEvent event) {
       // 内部拦截注释代码
       // if (event.getAction() == MotionEvent.ACTION_DOWN){
       //    super.onInterceptTouchEvent(event);
       //    return false;
       // }
       // return true;
        int x = (int)event.getX();
        int y = (int)event.getY();

        switch(event.getAction()){
          case ACTION_DOWN:

              break;
          case ACTION_MOVE:

              int delX = x - mLastX;
              int delY = y - mLastY;
              if(Math.abs(delX) > Math.abs(delY)){
                  //左右滑动
                  return true;
              }
              break;
          case ACTION_UP:
              break;

          default:
              break;

        }
        mLastX = x;
        mLastY = y;
        return super.onInterceptTouchEvent(event);
    }
}
```

### SwiperRefreshLayout与ViewPager的事件冲突
