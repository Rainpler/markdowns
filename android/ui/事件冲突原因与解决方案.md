为什么会发生事件冲突呢，因为我们的xml布局中，是viewgroup包裹view的形式，因此view与view之间必定存在一个叠加的情况。当点击事件产生在view与view的重叠区，该由谁来处理这个事件，这就会导致事件冲突的发生。

首先，我们先来看两个事件冲突的例子。
#### 同一个控件的事件冲突
在这个例子中，对同一个按钮设置了onTouchListener和onClickListener，且在onTouch中返回了true，那么这会导致什么情况发生呢。Log中只有onTouch会被打印出来。明明都设置了事件为什么不能同时并存呢，这时候我们就要查看事件分发的代码了。
```java
public class MainActivity extends AppCompatActivity {

    private Button btn_click;
    private static final String TAG = "MainActivity";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        btn_click = findViewById(R.id.btn_click);
        btn_click.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Log.e(TAG, "onClick");
            }
        });
        btn_click.setOnTouchListener(new View.OnTouchListener() {
            @Override
            public boolean onTouch(View v, MotionEvent event) {
                Log.e(TAG, "onTouch: " + event.getAction());

                return true;
            }
        });
    }
}
```


在View的dispatchTouchEvent中可以看到，首先会检查mOnTouchListener!=null和view的状态是否为ENABLED两个条件是否成立，如果成立的话，则会调用listener的onTouch()方法，且onTouch()返回了 true ，这个事件就会被消费。

否则，则调用自身的onTouchEvent()来处理。

```java
public boolean dispatchTouchEvent(MotionEvent event) {
      ...
      //noinspection SimplifiableIfStatement
      ListenerInfo li = mListenerInfo;
      if (li != null && li.mOnTouchListener != null
              && (mViewFlags & ENABLED_MASK) == ENABLED
              && li.mOnTouchListener.onTouch(this, event)) {
          result = true;
      }

      if (!result && onTouchEvent(event)) {
          result = true;
      }
      ...
      return result;
```
在View的onTouchEvent()方法中，会判断其是否可以点击，clickable或者longClickable，contextClickable，如果可以点击，则调用PerformClick()方法，并返回true表示消费事件，否则返回false。
```java
public boolean onTouchEvent(MotionEvent event) {
        ...

        final boolean clickable = ((viewFlags & CLICKABLE) == CLICKABLE
                || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

        if ((viewFlags & ENABLED_MASK) == DISABLED) {
            return clickable;
        }


        if (clickable || (viewFlags & TOOLTIP) == TOOLTIP) {
            switch (action) {
                case MotionEvent.ACTION_UP:
                    if (mPerformClick == null) {
                          mPerformClick = new PerformClick();
                    }
                    if (!post(mPerformClick)) {
                        performClickInternal();
                    }
                    ...
                    break;

                case MotionEvent.ACTION_DOWN:
                    ...
                    break;

                case MotionEvent.ACTION_CANCEL:
                    ...
                    break;

                case MotionEvent.ACTION_MOVE:
                    ...

                    break;
            }

            return true;
        }

        return false;
    }
```

#### 不同控件的事件冲突
我们再来看另一个例子，在布局中，我们放一个自定义的viewpager，viewpager中放一个竖向的ListView列表。在自定义的viewpager中，我们重写onInterceptTouchEvent。
```java
public class BadViewPager extends ViewPager {

      @Override
      public boolean onInterceptTouchEvent(MotionEvent event) {

       return true;
       // return false;
     }
```
当onInterceptTouchEvent方法返回为true的时候，表示拦截子view的touch事件，这样会导致viewpager可以作为滑动，但是listview无法滑动。如果返回为false的话，表示不拦截子view，这时候会导致listview可以滑动，但viewpager无法滑动。如果我们直接将该方法注释掉，这是viewpager换个listview都可以滑动了。

所以为什么会有这样奇怪的现象产生呢？
