### APK文件反编译
首先，我们先来了解一下什么是编译。我们编写的Java代码，称之为高级语言，因为这是程序员认识的语言。但是我们的计算机，是不认识这样的语言的，因此，高级语言就需要通过编译，转成低级语言让计算机去执行。

相反的，反编译就是，从低级语言反向工程，去获取其源代码的过程。

我们虽然很难将机器语言反编译成源代码，但是，我们还是可以把中间代码进行反编译的。就像我们虽然不能把经过虚拟机编译后的机器语言进行反编译，但是我们把javac编译得到的class进行反编译还是可行的。

所以，我们说Java的反编译，一般是将class文件转换成java文件。
#### 怎么进行反编译
我们来看了解apk的文件结构，通过修改apk文件后缀名为zip，解压得到文件夹，可以看到以下几个文件（文件夹）
![](https://ae01.alicdn.com/kf/U25dec2ae421d47eba64982fb1d1d5ff0o.jpg)
- META-INF 签名文件
- res 资源文件夹
- AndroidManifest.xml 清单文件
- classes.dex  Dalvik可执行文件，里面包含了app中的所有源码，因此反编译就是通过该文件获取java源码
- resources.arsc app的资源索引表

使用dex2jar可以将classes.dex转变为jar包，再通过jd-gui就可以查看class文件的内容了。但是现在的Andriod开发，为了防止反编译，都会进行代码混淆和加固，以防止代码的泄漏。
### APK加固的方案原理

Apk加固有多种方案，这里就简单提到几种常见的。
#### 加固方案的手段
1. 反模拟器

模拟器运行apk，可以用模拟器监控到apk的各种行为，所以在实际的加固apk运行中，一旦发现模拟器在运行该APK，就停止核心代码的运行。

2. 代码虚拟化

代码虚拟化在桌面平台应用保护中已经是非常的常见了，主要的思路是自建一个虚拟执行引擎，然后把原生的可执行代码转换成自定义的指令进行虚拟执行。

3. 加密

样本的部分可执行代码是以压缩或者加密的形式存在的，比如，被保护过的代码被切割成多个小段，前面的一段代码先把后面的代码片段在内存中解密，然后再去执行解密之后的代码，如此一块块的迭代执行。

### AES加密项目实战
这里，我们利用dex加壳的例子来进行加固实战。

#### 加固总体框架
对于一个apk，我们对它进行解压，得到dex源文件和其他文件。对于dex源文件进行AES加密，我们要把文件里面的二进制数据都进行AES加密，然后再写回到dex文件中。这里面涉及到大量的I/O。

我们再有一个dex壳文件，然后与dex源文件合并，重新打包成apk，并重新签名。

那么，在这里我们还有几个问题？
- dex文件可以随便拼凑吗？
- 壳dex 怎么来的
- 如何签名？
- 如何运行新apk（如何脱壳）？

加固的目的是保护dex，直接而言就是对dex文件进行操作，对dex文件动刀子，就像外科医生动手术一样，我们必须掌握dex的构造。

**Dex文件结构**

| header | string_ids   | type_ids   | proto_ids   | field_ids | metod_ids  | class_defs | data   | link_data  |
| ------ | ------------ | ---------- | -------------- | --------- | ------ | ---------- | ------ | ---------- |
| 文件头 | 字符串的索引 | 类型的索引 | 方法原型的索引 | 域的索引  | 方法的索引 | 类的定义区 | 数据区 | 链接数据区 |

我们了解了dex文件的构造，就可以在相应的文件区域进行修改，而不破坏dex文件的整体结构。

**Android 的打包流程**
